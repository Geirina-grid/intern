// **********************************************************************************************************************************
// This code is a fast-decoupled power flow solver, using version of the fast-decoupled. 
// GRAPHLU is implemented in the code to perform the LU factorization.
//
// Some back ground about this query. READ THIS FIRST.
//
// ------ This query requires GraphSQLv0.8.1/TigerGraphv1.2.0 at least and the schema is schema_EMS.ddl -----------
// The orginal version of this query is based on previously developed Fast Decoupled Power Flow query fdpf_flat_graphlu_bmk_v8.gsql and fdpf_flat_nicslu_LU_9_mod_graphsql44.gsql

// The idea here is to separate cases depending on whether the system topology has changed.
//
// For power flow analysis, Ybus matrix is used to represent the system as a mathematical model. In Fast-Decoupled method, assumptions
// and approximations are made to simplify the computational complexity such that constant matrices B' and B" are formed and dependencies
// between P,Q and V, angle are decoupled such that P depends only on angle and Q depends only on V.
//
// B' and B" matrices are constant (depend only on system parameters but not on state variables) and do not change through out the entire
// iteration process. In this case, B' and B" can be LU factorized once in the beginning and the iterations can be carried out 
// using the power balance equations and the factorized LU matrices with forward/backward substitution.
// In the original fdpf_flat_graphlu_bmk_v8 query, GRAPHLU (third party LU factorization library) is used to factorize the B' and B" once
// every time the query is ran.
//
// In power system normal operations, system topology does not change very often. When the topology is unchanged, Ybus matrix remains 
// unchanged, and B' and B" matrices remain unchanged. There is no need to factorize these matrices again if the LU matrices from
// the previous run are stored and can be re-used.
//
// When running power flow on a particular system for the first time or known topological changes have been made, 
// LU factorization of B' and B" is performed. The power flow iterations are carried out as usual and the factorized L and U are 
// stored in memory.  
//
// When there is no known topological changes, the query takes the stored factorized LU matrices and proceed with the iterations
// directly using forward/backward substitution. 
//
// In this version, the static classes in C++ used for storing the factorized L'U' and L"U" are STATIC. These static classes are populated in
// the expression function which performs LU factorization when the "factorize" option is 1. 
// Once the LU factorization is finished, LU matrices are directly used in sequential run to solve power flow.
// **********************************************************************************************************************************
// Developed by: Chen Yuan, chen.yuan@geirina.net
//               Xinyu Chang, xinyu@graphsql.com (support from graphsql)
// Version LU 9_mod
// History:
// 06/01/2016 [Ting Chan]: 
//            Seperate the solving and update of delta V and delta Phi similar to MATPOWER. First solve for and update 
//            delta Phi (angle). Update delta P and delta Q with new angle and check for convergence criteria. Then solve 
//            for and update delta V (voltage). Update delta P and delta Q again with new voltage. 
// 06/03/2016 [Ting Chan]:
//            Added non-flat start option. When this option is used, voltage magnitudes and angles use values from input data
//            file instead of flat start values (1 and 0).
// 06/06/2016 [Ting Chan]:
//            This version requires the input bus number (exId) to be consecutive. The size of B" is the same as B' which is 
//            n-1 x n-1. The input arrays (Ax, Ai, Ap) to GRAPHLU is based on v.@exId and assume the bus numbers are consecutive.
//            The "foreach" loop in version 1.5 is eliminated which improves performance. A C++ function (GRAPHLU_build_Ap) is 
//            written to get @@Bp_p and @@Bpp_p.
// 06/08/2016 [Ting Chan];
//            For version 1.6, the two blocks for updating voltage magnitude and angle with delta V and delta Phi are elinimated.
//            The updates are made in the block where delta P and delta Q are calculated. 
// 06/08/2016 [Nan Li];
//            LU factorization is only perfomred once in this version. The forward/backward substitution is performed is the 
//            C function.
// 06/21/2016 [Nan Li];
//            This is a benchmark for the query version of the fast-decoupled code. The fast decoupled is performed in the C++ function.
//            This is to provide a benchmark of how fast is the power flow program solved in C++.  
// 08/16/2016 [Ting Chan]
//            Change MapAccum to HeapAccum. Performance should be improved since there is no need to do ordering in C++.
// 08/19/2016 [Ting Chan]
//            Combine multiple HeapAccum into fewer HeapAccum to reduce sorting time.
// 09/02/2016 [Ting Chan]
//            Consolidate the logic for setting up the HeapAccums.
// 09/07/2016 [Ting Chan]
//            This version calls GRAPHLU_fdpf_v6 C function
// 09/22/2016 [Ting Chan]
//            added calls to get @Vr and @Vs from the HeapAccum.
// 10/24/2016 [Ting Chan]
//            Use one HeapAccum to store x and i for Ybus, B' and B". Call GRAPHLU_fdpf_v7.
// 11/02/2016 [Ting Chan]
//            Testing version for inserting fill-in edges based on factorized LU
// 11/15/2016 [Ting Chan]
//            Requires schema flowSchema_LU.ddl
// 01/05/2017 [Ting chan]
//            Updated to work with GraphSQL 4.4. Requires flowSchema_LU_graphsql44.ddl
//            Due to the removal of support for customized reducer function, the transformer tap ratio is no longer
//            being averaged (for parallel branches) during the loading stage. Instead, tap ratio for parallel branches 
//            are being read in as two attributes transformer_final_turns_ratio and kcount, then the average is taken in the query.
//            Tuple for edge sets uses integer for from/to buses.
// 01/09/2017 [Ting Chan]
//            Added control parameter (fillin) to specify whether we want to find the fill-ins. 
//            1 - find fill-ins
//            0 - otherwise
// 01/12/2017 [Ting Chan]
//            Modified the tuple to store factorized L and U values for B' and B"
// 01/17/2017 [Ting Chan]
//            This version calls GRAPHLU_fdpf_LU_fill_in_3 which replaced GraphLU_Solve with our own implementation of
//            forward/backward substitution.
// 01/18/2017 [Ting Chan]
//            Added a new tuple for holding the factorized values of the L matrix diagonal terms, row scaling factors, row permutation,
//            and row permutation inverse.
//            Both of these values are on the vertex of the B' and B" vertex type 
// 01/19/2017 [Ting Chan]
//            Added code to store factorized L value, scaling factors, etc., from the HeapAccums onto the vertices.  
// 01/20/2017 [Ting Chan]
//            Changed the original user input "fillin" to "factorize"
//            1 - Power flow is being run for the first time on the particular system or there has been topological changes.
//                Construct B' and B" from scratch based on Gnode. In C function, perform LU factorization of B' and B", stored factorized
//                LU information (fill-in edges, factorized values, scaling factors, etc.) into SetAccums and HeapAccums. Create/update
//                vertices and edges with factorized information.
//            0 - Power flow has previously been run on the system. 
//                LUpnode and LUppnode contain information of the factorized B' and B". In C function, no LU factorization is performed and
//                only do power flow iteration and forward/backward substitution.
// 01/23/2017 [Ting chan]
//            Added construction of HeapAccums for the factorized LU of B' and B" (L'U', L"U").
// 01/23/2017 [Ting Chan]
//            Consolidated HeapAccums for factorized L'U' and L"U" to reduce sorting time. Originally there are two 
//            HeapAccums for L and U. They are now consolidate into one in an attempt to reduce sorting time.     
// 01/25/2017 [Ting Chan]
//            Added another user input parameter "insert_LU". This option is only meaningful if "factorize" is also enabled (1). If "factorize"
//            is disabled (0), this option does nothing. 
//            1 - If "factorize" is also enabled (1), dump factorized LU in C function and store them in Set/HeapAccums. 
//                In query, insert/update LU edges and vertices with factorized values and information (permutation, scaling, etc.)
//            0 - If "factorize" is enabled (1), B' and B" are factorized, but the resulting LUs are not stored. LU edges and vertices
//                are not updated. 
//            This option is provided here only to check the performance of inserting/updating edges and vertices. Under normal circumstances it
//            should always be 1. 
// 01/26/2017 [Ting Chan]
//            Added storing of the factorized LU pointers onto the vertex. In the non-factorized option, added the pointers in the HeapAccums. 
// 01/30/2017 [Ting Chan]
//            Changed rpi to cpi on all tuples.   
// 01/31/2017 [Ting Chan]
//            Get sizes of L', U', L", and U" HeapAccums and pass them as inputs to expression function  
// 02/01/2017 [Ting Chan] 
//            Added Uvalue on tuples sort_id_vertex_factorized to store the factorized values on the diagonal of the U matrix.
//            Added updating the vertex with Uvalue. When building factorized LU matrix HeapAccums, add the vertex Uvalues. 
// 02/02/2017 [Ting Chan]
//            Added rpi (row permutation inverse) and cperm (column permutation) on sort_id_vertex_factorized 
// 02/03/2017 [Ting Chan]
//            Added col_scale (column scaling factor) on sort_id_vertex_factorized and col_scaling on sort_cpi_vertex
// 02/04/2017 [Ting Chan]
//            added flags Lflag and Uflag on the factorized tuples to indicate whether the edge/vertex has a L or U factor or both 
//            (These might not be necessary!!!!)
// 02/06/2017 [Ting Chan]
//            added Lflag and Uflag to the sort_rpi_cpi_matrix tuple (I still think this might not be necessary, but do this for now.
//            If these flags can be omitted, we can simplify the HeapAccums which should improve the performance by speeding up
//            the HeapAccum creation in gsql and sorting time in C expression function)
// 02/06/2017 [Ting Chan]
//            Removed the tuple and SetAccum for inserting/updating edges for the factorized LU matrices. These are no longer needed
//            in gsql as the "upsert" is now being done in the C expression function.
// 02/07/2017 [Ting Chan]
//            Removed the tuple and HeapAccum for updating vertex attributes. these are no longer needed in gsql as the updates are
//            now being done in the C expression function via upsert.
// 02/08/2017 [Ting Chan]
//            Removed Lflag and Uflag from the sort_rpi_cpi_matrix tuple. These are not needed in the factorized matrix HeapAccum.
//            The determination of whether it is a L factor or U factor is done based on its value in the expression function. 
//            (see the 02/06/2017 comment)
// 02/08/2017 [Ting Chan]
//            The previous change removed the usage of Lflag and Uflag. This change introduced issues when testing the 
//            sc_20160818_1120 case. Apparaently there are zero element in the factorized LU structure by GRAPHLU for this case.
//            The current fix for this is to avoid using the stored pointer information on the vertex, but we should investigate 
//            why a zero element is included in GraphLU_DumpLU. For now, instead of using Lpointer and Upointer on the vertex,
//            use counters @Lnum and @Unum to store the degree of each vertex. The logic in the expression function is also updated
//            accordingly. 
// 02/17/2017 [Ting Chan]
//            Added STATIC for HeapAccums that do NOT need to be rebuild and user option "rebuild".
//            1 - Topology has changed and factorization has been performed, rebuild the HeapAccums. Sorting is needed in the
//                expression function.
//            0 - Topology hasn't changed and the HeapAccums have already been built and sorted in the past. Only need to rebuild
//                and sort the HeapAccum (@@vertex_Ybus) which contains state variables.
//            This is currently implement as an user option but should be improved in the future so that the query detects whether
//            or not HeapAccums need to be rebuilt. This can be simply done with a new STATIC global variable to indicate whether
//            B' and B" has been refactored.  
// 02/19/2017 [Ting Chan]
//            Removed the tuple sort_id_matrix_Ybus and HeapAccum @@matrix_Ybus since the @@matrix_all HeapAccum is static. @@matrix_all
//            is built and sorted during the factorization stage when there is known topology changes. When there is no topology changes
//            @@matrix_all can be re-used to get the Ybus.
// 02/20/2017 [Ting Chan]
//            Removed the "rebuild" option. Logic is added in the query to decide whether static HeapAccums with conatins factorized
//            LU matrices need to be rebuilt or not. The intention was to make this query more robust so that user does not need to 
//            have knowledge on when or not to do the rebuild.
// 02/21/2017 [Ting Chan]
//            Fixed the bug when setting up run_option. Although HeapAccums are cleared when "factorize" is enabled (1), the next time 
//            when the query runs, the copy of the static HeapAccum has a bug which prevents it from copying since there is no change.
//            This bug leads to the setting of wrong run_option and is reported to GraphSQL. At the mean time, instead of checking
//            the size of HeapAccums to set run_option, check the values of static SumAccums instead. 
// 02/22/2017 [Ting Chan]
//            When "factorize" is 1, use STATIC HeapAccums to store the factorized LU matrices and re-use them in sequential runs.
//            Factorized LU matrix information are NO LONGER stored on edge/vertex and the "upsert" in expression function is
//            removed.
// 02/22/2017 [Ting Chan]
//            Use seperate HeapAccums to store factorized L and U matrix.
// 02/23/2017 [Ting chan]
//            Removed the sizing SumAccums which was used to indicate the number of non-zeros in the factorized LU matrices.
//            They are no longer needed since we are now using seperate HeapAccums to store the LU matrices and the number of 
//            non-zeros is the HeapAccum size. 
// 02/23/2017 [Ting Chan]
//            Added .clear() for @@matrix_all when "factorize" is 1. If LU factorization is to be performed, we should clear this
//            HeapAccum and rebuild it to represent the latest Ybus, B' and B".
// 02/24/2017 [Ting Chan]
//            Tested working with schema version flowSchema_graphsql44.ddl which has only one type of vertex and edge. 
// 02/27/2017 [Chen Yuan]
//			  Added ListAccum to create edge container for printing edges out on Visualization. This is modified based on fdpf_flat_graphlu_LU_9_mod_graphsql44.gsql
// 03/12/2017 [Chen Yuan]
//			  Added transmission line power flow as an attribute on the edge. Conducted transmission line power flow calculation,and updated them on edge attributes
//            Added substation name and location, including longitude and latitude, as vertex attributes
//            Use flowSchema_LU9_mod_vis_graphsql44.ddl and loadFlow_******_LU9_mod_vis_graphsql44.gsql;
// 03/13/2017 [Chen Yuan]
//            Added overvoltage (OV) and undervoltage (UV) attributes on vertex,
//            when bus voltage's upper limit (up_V) is violated, OV = 1,
//            when bus voltage's lower limit (lo_V) is violated, UV = 1,
//            Added transmission capacity congestion indication (CI) attribute on edge, 
//            when CI = 0, indicating no violation, 
//            when CI = 1, it indicates th load shedding limit (ls) is violated,
//            when CI = 2, it indicates the emergency limit (em) is violated, 
//            when CI = 3, it indicates the thermal limit (th) is violated.
// 07/18/2017 [Chen Yuan]Hard code inputs for power flow visualization demo: max_change_ex = 0.05; ExMaxIteration = 10; initial_Va = 0; initial_Vm = 1;
//
// 06/07/2018 [Chen Yuan] Connect with topology processing query. Continuous exId function is employed to assign continuous exId to vertices; With help of topology processing, token bank function is no more needed in this query.


// Todo List
// 06/07/2018 [Chen Yuan] parameters of this query are stored at a vertex. In this way, user can customize these parameters and front-end will correspondingly change these parameters at that vertex. Then this query will fetch thees parameters' information from the vertex. 

// 06/08/2018 [Chen Yuan] Use static classes to store LU components of B' and B'', replacing previously STATIC HeapAccum function. In this way, other queries can see these stored information. Otherwise, other queries are hardly to see STATIC HeapAccum Information.



//*********************************************************************************************************************************************************************************
//*************************************************** ATTENTION! ATTENTION! ATTENTION! ********************************************************************************************
//*********************************************************************************************************************************************************************************  

         
// !!!!!!!!!!  CURRENTLY, NO AVAILABLE DATA FOR VOLTAGE LIMITS (up_V and lo_V) AND TRANSMISSION LINE LIMITS (ls, em, th). RANDOM CHOSEN VALUES ARE SET BELOW FOR TESTING ONLY   !!!!!!!

//*********************************************************************************************************************************************************************************
//*************************************************** ATTENTION! ATTENTION! ATTENTION! ********************************************************************************************
//********************************************************************************************************************************************************************************* 
  

// *****************************************************************************************************************************************************************

// Drop previous queries
drop query FDPF_EMS

// ==================================================================================================================================
//		                          Main Function of the Code
// ==================================================================================================================================
// create query FDPF_EMS (double max_change, int max_iteration, double initial_Va, double initial_Vm, int flatstart, int factorize)
create query FDPF_EMS ()
for graph gsql_EMS {
  
// ------------------------------------------------------------------------------------------------
// 				Define variables and arrays
// ------------------------------------------------------------------------------------------------

 // define the tuples for the HeapAccums and SetAccums
 // sort_id_vertex:     for the vertex HeapAccum (key based on exId) 
 //                     - contains information on the nodes and also for the pointer arrays 
 typedef tuple<int key, int Bp_p, int Bpp_p, int ep, double Vm, double Va, double Pn, double Qn, int bustype> sort_id_vertex;
 
 // sort_id_matrix_all: for the matrix_all HeapAccum (key based on exId) 
 //                     - contains Ybus matrix G & B, B' matrix and B" matrix B values 
 //                       and index array (both edge and node info)
 typedef tuple<int key, double eG, double eB, int ei, double Bp_x, double Bpp_x, double line_Q1> sort_id_matrix_all;

 // sort_id_vertex_Ybus:for the vertex_Ybus HeapAccum (key based on exId) 
 //                     - an trim down version of sort_id_matrix_all that contains only Ybus 
 //                       information on the nodes and also for the pointer arrays 
 typedef tuple<int key, int ep, double Vm, double Va, double Pn, double Qn, int bustype> sort_id_vertex_Ybus;
  
 // sort_id_matrix_Ybus:for the matrix_Ybus HeapAccum (key based on exId) 
 //                     - an trim down version of sort_id_matrix_all that contains only Ybus matrix G & B, 
 //                       and index array (both edge and node info)
 //typedef tuple<int key, double eG, double eB, int ei> sort_id_matrix_Ybus; 
 
 // sort_rpi_cpi_matrix:for the L'U' and L"U" matrix HeapAccums (key based on rpi and cpi)
 //                     - contains factorized LU values of B' and B" (both edge and node) 
 typedef tuple<int key, int cpi, double value> sort_rpi_cpi_matrix;
 
 // sort_rpi_vertex:    for the L'U' and L"U" matrix vertex HeapAccums (key based on rpi) 
 //                     - contains pointers, permutation and scaling info  
 typedef tuple<int key, int Lp, int Up, int rp, int cpi, double row_scaling, double col_scaling, int exId> sort_rpi_vertex;

 // run_option to indicate whether LU factorization or rebuild HeapAccums is needed.
 // if 0 - do LU factorization
 // if 1 - rebuild HeapAccum
 // if 2 - solve power flow only (LU factorization was performed and HeapAccums already built) 
 SumAccum<int> @@run_option;
 
 // ************************************************************************************
 // Definition of variables that are needed regardless of "factorize" option  
 // ************************************************************************************
 // define PI value
 MaxAccum<double> @@PI = 3.1415926535898;
 
 // [Testing for Visualization, Chen Yuan]
 //SetAccum<edge>  @@edgeSet;    // Added by Chen Yuan
 ListAccum<edge> @@edgeList;   // Added by Chen Yuan
 //ListAccum<vertex> @@nodeList;   // Added by Chen Yuan

 SumAccum<double> @sumG  = 0; // store for each node the total G on all of its edges
 SumAccum<double> @sumB  = 0; //similar...
 SumAccum<double> @sumBi = 0;
 SumAccum<double> @cal_P = 0;
 SumAccum<double> @cal_Q = 0;
 
 //OrAccum @@showLog = false;

 // Bus Types - PQ:0/1 PV:2 SLC:3 GND:4
 //SumAccum<double> @P = 0;
 //SumAccum<double> @Q = 0;
 //SumAccum<double> @Vm = 0;
 //SumAccum<double> @Vr = 0;
 //SumAccum<double> @Vs = 0;
 
 SumAccum<int>    @alldgr = 0;   // the degree (number of edges connecting all buses) of a bus
 string basecase_result;
 
 // ************************************************************************************
 // Definition of variables needed only if "factorize" option is enabled(1)
 // ************************************************************************************ 
 SumAccum<int>    @pqvdgr = 0;   // the degree (number of edges connecting PV or PQ buses) of a bus
 SumAccum<int>    @pqdgr = 0;    // the degree (number of edges connecting PQ buses) of a PQ bus
 
 // define the HeapAccums, sorted based on ascending order of the key (key based on exId)
 // The vertex HeapAccum which contains system state information like P, Q needs to be rebuild
 // everytime
 // HeapAccum<sort_id_vertex>(100000000, key asc) @@vertex; 
 HeapAccum<sort_id_vertex>(100000000, key asc) @@vertex; 
 
 // The HeapAccum for Ybus, B' and B" matrix. This one only needs to be rebuild when there is
 // known topology changes so LU factorization needs to be performed ("factorize" = 1)
 //STATIC HeapAccum<sort_id_matrix_all>(100000000, key asc) @@matrix_all; 
 HeapAccum<sort_id_matrix_all>(100000000, key asc) @@matrix_all;
 
 // store the number of non-zeros in B' and B"
 SumAccum<int> @@Bp = 0;
 SumAccum<int> @@Bpp = 0; 
 
 // STATIC HeapAccum<sort_rpi_cpi_matrix>(100000000, key asc) @@p_L_matrix;
 // STATIC HeapAccum<sort_rpi_cpi_matrix>(100000000, key asc) @@p_U_matrix;
 // STATIC HeapAccum<sort_rpi_cpi_matrix>(100000000, key asc) @@pp_L_matrix;
 // STATIC HeapAccum<sort_rpi_cpi_matrix>(100000000, key asc) @@pp_U_matrix;
 // STATIC HeapAccum<sort_rpi_vertex>(100000000, key asc) @@p_LU_vertex;
 // STATIC HeapAccum<sort_rpi_vertex>(100000000, key asc) @@pp_LU_vertex;
 
 
  
 // ************************************************************************************
 // Definition of variables needed only when NOT doing factorization ("factorize" = 0)
 // ************************************************************************************ 
 // If NOT performing factorization, use a trim down version of HeapAccums for Ybus.
 // This one needs to be rebuild everytime since it contains state information  
 HeapAccum<sort_id_vertex_Ybus>(100000000, key asc) @@vertex_Ybus;
 
 
 // ********************************* Attributes Update ********************************
 // MapAccum<int, double> @G;
 // MapAccum<int, double> @B;
 // MapAccum<int, double> @hBsum;
 // MapAccum<int, double> @K;
 // //MapAccum<int, double> @kcount;
 // MapAccum<int, double> @BIJ; 
 // MapAccum<int, double> @th; 
 // MapAccum<int, double> @em;
 // MapAccum<int, double> @sh;  
  MapAccum<int, int> @@counterMap;
 
 // ********************************* Countinuous exId Attributes ************************
 ListAccum<int> @@nodeList;
 //SumAccum<int> @@counter = 0;
 
 // ********************************* Query Parameters Definition ************************
 SumAccum<double> @@max_change = 0.05;
 SumAccum<double> @@initial_Va = 0;
 SumAccum<double> @@initial_Vm = 1;
 SumAccum<int> @@max_iteration = 10;
 SumAccum<int> @@flatstart = 1;
 SumAccum<int> @@factorize = 1;
 SumAccum<string> @@outputfile = "/home/graphsql/output/output.txt";

 // ************************************************************************************
 // End of variable definition
 // ************************************************************************************
T0= {TopoND.*};   //start from all vertices in the graph
T_params = {parameters.*}; // include the parameters vertex

 // ****************** Transfer parameters vertex attributes to this query's parameters ********************
 
//T_params = SELECT s FROM T_params:s 
			//POST-ACCUM
			//@@max_change += 0.05;
			//@@initial_Va += 0;
			//@@initial_Vm += 1;
			//@@max_iteration += 10;
			//@@flatstart += 1;
			//@@factorize += 1;
			//@@outputfile += "/home/graphsql/output/output.txt;
			//log(true, s.pf_MaxChange, s.initial_Va, s.initial_Vm, s.pf_MaxIter, s.pf_flatstart, s.factorize);
			
			//1,0.05,10, 1, 0, 1, 1, 0.0001, 10, 1, "/home/graphsql/output/output/output.txt", _, _, _, _
			
 //log(true, max_change, initial_Va, initial_Vm, max_iteration, flatstart, factorize);

 // ********************************* Continuous exId ************************************
 
 //@@counter += T0.size();
 
 // T1 = SELECT s
	  // FROM T0:s-(topo_connect:e)->TopoND:t
	  // WHERE s.island == 1 and t.island == 1
	  // post-accum
	  // @@nodeList += s.TOPOID;
	  
 // //FOREACH x in @@nodeList DO
	// //@@counter += 1;
	// ////x.exId = @@counter;
	// //x.exId = @@counter;
 // //END;
 
 // setCounterMap(@@counterMap, @@nodeList);
 
 // T2 = select s 
	  // from T1:s 
	  // WHERE s.island == 1
	  // post-accum 
	  // s.exId = @@counterMap.get(s.TOPOID);
 
 
 // // ********************************** Token Bank Function *****************************
 
 // T2 = select s
	  // from T0:s-(connected:e)-:t
	  // accum
	   // //int size = e.R.size() - 1,  // need to be double checked and improved later.....
            // //IF (size < 0) THEN
                // //size = 0
            // //END,
		    // FOREACH i in range[0, e.R.size() - 1] DO
				// //s.@G += (t.exId -> e.R.get(i)/(e.R.get(i)*e.R.get(i) + e.X.get(i)*e.X.get(i))),
				// //s.@B += (t.exId -> e.X.get(i)/(e.R.get(i)*e.R.get(i) + e.X.get(i)*e.X.get(i))),
				// //s.@hBsum += (t.exId -> e.hB.get(i)),
				// //s.@K += (t.exId -> e.transformer_final_turns_ratio.get(i)),
				// //s.@kcount += (t.exId -> 1),
				// //s.@BIJ += (t.exId -> 1.0/e.X.get(i))
				
				// s.@G += (t.ID -> e.R.get(i)/(e.R.get(i)*e.R.get(i) + e.X.get(i)*e.X.get(i))),
				// s.@B += (t.ID -> e.X.get(i)/(e.R.get(i)*e.R.get(i) + e.X.get(i)*e.X.get(i))),
				// s.@hBsum += (t.ID -> e.hB.get(i)),
				// s.@K += (t.ID -> e.transformer_final_turns_ratio.get(i)),
				// //s.@kcount += (t.exId -> 1),
				// s.@BIJ += (t.ID -> 1.0/e.X.get(i)),
				// s.@th += (t.ID -> e.line_Q1.get(i)),
				// s.@em += (t.ID -> e.Line_Q2.get(i)),
				// s.@sh += (t.ID -> e.Line_Q3.get(i))
				
// /* 				e.B = e.B + e.X.get(i)/(e.R.get(i)*e.R.get(i) + e.X.get(i)*e.X.get(i)),
				// e.hB = e.hB + e.hB.get(i),
				// e.K = e.K + e.turnsratio.get(i),
				// e.kcount = e.kcount + 1,
				// e.BIJ = e.BIJ + 1.0/e.X.get(i) */
				
				
 			   // // @@edgeList+= row(s.exId, t.exId, e.area, e.zone, e.circuit, e.flag.get(i), e.R.get(i), e.X.get(i), e.hB.get(i), e.line_Q1.get(i), e.Line_Q2.get(i), e.Line_Q3.get(i), e.control_bus, e.side, e.K, e.transformer_final_angle, e.Min_tap, e.Max_tap, e.step_size, e.Min_volt.get(i), e.Max_volt.get(i))
			// END;
			
  // T2 = select s
	   // from T0:s-(connected:e)-:t
	   // accum
		 // e.G = s.@G.get(t.ID),
		 // e.B = s.@B.get(t.ID),
		 // e.hBsum = s.@hBsum.get(t.ID),
		 // e.K = s.@K.get(t.ID),
		 // //e.kcount = s.@kcount.get(t.exId),
		 // e.BIJ = s.@BIJ.get(t.ID),
		 // e.th = s.@th.get(t.ID),
		 // e.em = s.@em.get(t.ID),
		 // e.sh = s.@sh.get(t.ID)
		 
		 // //CASE WHEN (e.kcount == 0) THEN
			// //e.kcount = 2   // for fj case edge 66-71 and 71-66
		 // //END,
		 // //log(true,s.ID, t.ID, e.kcount)
	   // post-accum
		 // s.P = s.GenP - s.LdP,
		 // s.Q = s.GenQ - s.LdQ,
		 // s.@G.clear(),
		 // s.@B.clear(),
		 // s.@hBsum.clear(),
		 // s.@K.clear(),
		 // //s.@kcount.clear(),
		 // s.@BIJ.clear(),
		 // s.@th.clear(),
		 // s.@em.clear(),
		 // s.@sh.clear();
	   
			
  // // T3 = select s
	   // // from T0:s-(connected_reverse:e)-:t
	   // // accum
	   // // //int size = e.R.size() - 1,  // need to be double checked and improved later.....
            // // //IF (size < 0) THEN
                // // //size = 0
            // // //END,
		    // // FOREACH i in range[0, e.R.size() - 1] DO
				// // s.@G += (t.exId -> e.R.get(i)/(e.R.get(i)*e.R.get(i) + e.X.get(i)*e.X.get(i))),
				// // s.@B += (t.exId -> e.X.get(i)/(e.R.get(i)*e.R.get(i) + e.X.get(i)*e.X.get(i))),
				// // s.@hBsum += (t.exId -> e.hB.get(i)),
				// // s.@K += (t.exId -> (-1) * e.transformer_final_turns_ratio.get(i)),
				// // s.@kcount += (t.exId -> 1),
				// // s.@BIJ += (t.exId -> 1.0/e.X.get(i))
				
				
 			   // // //@@edgeList+= row(s.exId, t.exId, e.area, e.zone, e.circuit, e.flag.get(i), e.R.get(i), e.X.get(i), e.hB.get(i), e.line_Q1.get(i), e.Line_Q2.get(i), e.Line_Q3.get(i), e.control_bus, e.side, e.K, e.transformer_final_angle, e.Min_tap, e.Max_tap, e.step_size, e.Min_volt.get(i), e.Max_volt.get(i))
			// // END;
			
			
  // // T3 = select s
	   // // from T0:s-(connected_reverse:e)-:t
	   // // accum
		 // // e.G = s.@G.get(t.exId),
		 // // e.B = s.@B.get(t.exId),
		 // // e.hBsum = s.@hBsum.get(t.exId),
		 // // e.transformer_final_turns_ratio = s.@transformer_final_turns_ratio.get(t.exId),
		 // // e.kcount = s.@kcount.get(t.exId),
		 // // e.BIJ = s.@BIJ.get(t.exId)
	   // // post-accum
	     // // s.P = s.GenP - s.LdP,
		 // // s.Q = s.GenQ - s.LdQ,
		 // // s.@G.clear(),
		 // // s.@B.clear(),
		 // // s.@hBsum.clear(),
		 // // s.@transformer_final_turns_ratio.clear(),
		 // // s.@kcount.clear(),
		 // // s.@BIJ.clear();
	// // T3 = T1 UNION T2;
 

 //print @@p_LU_matrix.size(), @@pp_LU_matrix.size(), @@p_LU_vertex.size(), @@pp_LU_vertex.size();
 //print @@Lp, @@Up, @@Lpp, @@Upp;
 // logic to decide whether LU factorization or rebuild of HeapAccum is needed
 //if (factorize == 1 or @@matrix_all.size() == 0) {
 if (@@factorize == 1) {
   // Perform LU factorization from scratch either if
   // 1 - user option "factorize" is enabled or,
   // 2 - @@matrix_Ybus is empty indicating LU factorization hasn't been performed 
   // set run_option to 0 (by default)
   @@run_option = 0;
   
   // topology has been changed and B' and B" are to be factorized, clear all static HeapAccums.
   // They need to be rebuilt.      
   // Initialize the STATIC HeapAccums. This is needed here only because GraphSQL 
   // would need to detect a change to copy it. For more detail, check with Xinyu.
   // @@matrix_all += sort_id_matrix_all(1, 1, 1, 1, 1, 1);
   // @@p_LU_vertex += sort_rpi_vertex(1, 1, 1, 1, 1, 1, 1, 1);
   // @@p_L_matrix += sort_rpi_cpi_matrix(1, 1, 1); 
   // @@p_U_matrix += sort_rpi_cpi_matrix(1, 1, 1);     
   // @@pp_LU_vertex += sort_rpi_vertex(1, 1, 1, 1, 1, 1, 1, 1);
   // @@pp_L_matrix += sort_rpi_cpi_matrix(1, 1, 1);
   // @@pp_U_matrix += sort_rpi_cpi_matrix(1, 1, 1);
   
   // //clear the STATIC HeapAccums
   // @@matrix_all.clear();
   // @@p_LU_vertex.clear();
   // @@p_L_matrix.clear(); 
   // @@p_U_matrix.clear();     
   // @@pp_LU_vertex.clear();
   // @@pp_L_matrix.clear();
   // @@pp_U_matrix.clear();
 } 
 
 // comment temporarily
 // else {  
 // // When it gets here, it means 
 // // 1 - @@matrix_Ybus is not empty --> LU factorization was performed in the past
 // // 2 - HeapAccums for the factorized LU structure have been built
 // // There is no need to build them in gsql or sort in expression function. 
 // // set run_option to 2  
   // @@run_option = 2;
 // }
 
// ------------------------------------------------------------------------------------------------
// 			Construct Ybus and get the B matrix for fast-decoupled method
// ------------------------------------------------------------------------------------------------     
if (@@run_option == 0)
{
  // run_option is 0 --> perform LU factorization from scratch.
  // Either:
  // 1 - user option "factorize" is enabled or,
  // 2 - @@matrix_Ybus is empty indicating LU factorization hasn't been performed 
  // topology has been changed and B' and B" are to be factorized, all static Accums
  // have been cleared and resetted to 0 as they need to be rebuilt.
  print "Performing LU factorization of B' and B'' matrix and solve Power Flow!";
    
  //if factorize is true, construct Ybus, B' and B" from scratch
  T3 = select v
	   from T0:v-(topo_connect:e)->TopoND:t
	   //WHERE v.island == 1 and t.island == 1
	 //where e.outage == 0   // meaning no outage on this line
     accum   
       //compute the G and B contribution of the branches to the diagonal terms         
       case when (e.transformer_final_turns_ratio == 0) then 
           //compute contribution of each branch to the diagonal terms 
  		   v.@sumG += e.G, 
           v.@sumB += -1*e.B + 0.5*e.hB,
           v.@sumBi += -1*e.BIJ, // used to construct the B' matrix for fast-decoupled method
           // if it is NOT connecting to the slack bus
           case when (v.busType != 3 and t.busType != 3) then  
             @@Bp += 1,   
             v.@pqvdgr += 1, // get the total number of edges connecting PQ and PV buses to node v 
             // if both side are PQ bus
             case when ((v.busType == 0 or v.busType == 1) and (t.busType == 0 or t.busType == 1)) then
               //both B' and B"
               @@Bpp += 1,
               @@matrix_all += sort_id_matrix_all(v.exId*100000 + t.exId, -e.G, e.B, t.exId - 1, e.BIJ, e.B, e.line_Q1),
               v.@pqdgr += 1 // get the total number of edges connecting ONLY PQ buses to node v
             else //at least one side is PV side
               //B' only, set Bpp_x to 0
               @@matrix_all += sort_id_matrix_all(v.exId*100000 + t.exId, -e.G, e.B, t.exId - 1, e.BIJ, 0.0, e.line_Q1)
             end
           else
             //slack bus --> no B' or B'', set both Bp_x and Bpp_x to 0
             @@matrix_all += sort_id_matrix_all(v.exId*100000 + t.exId, -e.G, e.B, t.exId - 1, 0.0, 0.0, e.line_Q1)  
           end
       when (e.transformer_final_turns_ratio > 0) then
           //compute contribution of each branch to the diagonal terms
           double tap_ratio_square = (e.transformer_final_turns_ratio/e.kcount)*(e.transformer_final_turns_ratio/e.kcount),
           double tap_ratio = e.transformer_final_turns_ratio/e.kcount,
           v.@sumG += 1/(tap_ratio_square)*e.G,
           v.@sumB += 1/(tap_ratio_square)*(-1*e.B) + 0.5*e.hB, // sqrt
           v.@sumBi += -1*e.BIJ,
           case when (v.busType != 3 and t.busType != 3) then   
             @@Bp += 1,   
             v.@pqvdgr += 1, // get the total number of edges connecting PQ and PV buses to node v 
             // if both side are PQ bus
             case when ((v.busType == 0 or v.busType == 1) and (t.busType == 0 or t.busType == 1)) then
               //both B' and B"
               @@Bpp += 1,
               @@matrix_all += sort_id_matrix_all(v.exId*100000 + t.exId, -e.G/tap_ratio, e.B/tap_ratio, t.exId - 1, e.BIJ, e.B/tap_ratio, e.line_Q1),  
               v.@pqdgr += 1 // get the total number of edges connecting ONLY PQ buses to node v
             else //at least one side is PV side
               //B' only, set Bpp_x to 0
               @@matrix_all += sort_id_matrix_all(v.exId*100000 + t.exId, -e.G/tap_ratio, e.B/tap_ratio, t.exId - 1, e.BIJ, 0.0, e.line_Q1)  
             end
           else
             //slack bus --> no B' or B'', set both Bp_x and Bpp_x to 0
             @@matrix_all += sort_id_matrix_all(v.exId*100000 + t.exId, -e.G/tap_ratio, e.B/tap_ratio, t.exId - 1, 0.0, 0.0, e.line_Q1)  
           end      
       else
           //compute contribution of each branch to the diagonal terms 
           double tap_ratio = abs(e.transformer_final_turns_ratio/e.kcount), 
           v.@sumG += e.G, 
           v.@sumB += -1*e.B + 0.5*e.hB,
           v.@sumBi += -1*e.BIJ,
           case when (v.busType != 3 and t.busType != 3) then
             @@Bp += 1,
             v.@pqvdgr += 1, // get the total number of edges connecting PQ and PV buses to node v 
             // if both side are PQ bus
             case when ((v.busType == 0 or v.busType == 1) and (t.busType == 0 or t.busType == 1)) then
               //both B' and B"
               @@Bpp += 1,
               @@matrix_all += sort_id_matrix_all(v.exId*100000 + t.exId, -e.G/tap_ratio, e.B/tap_ratio, t.exId - 1, e.BIJ, e.B/tap_ratio, e.line_Q1), 
               v.@pqdgr += 1 // get the total number of edges connecting ONLY PQ buses to node v
             else //at least one side is PV side
               //B' only, set Bpp_x to 0
               @@matrix_all += sort_id_matrix_all(v.exId*100000 + t.exId, -e.G/tap_ratio, e.B/tap_ratio, t.exId - 1, e.BIJ, 0.0, e.line_Q1)  
             end
           else
             //slack bus --> no B' or B'', set both Bp_x and Bpp_x to 0
             @@matrix_all += sort_id_matrix_all(v.exId*100000 + t.exId, -e.G/tap_ratio, e.B/tap_ratio, t.exId - 1, 0.0, 0.0, e.line_Q1)  
           end      
       end,
       v.@alldgr += 1 // total number of connected branches
     post-accum
	 //Initialization of the state variables 
       case when @@flatstart == 0 then  //not using flat start, set voltage manitude/angle based on input data files
         case when v.busType == 1 or v.busType == 0 then 
           //v.P = (v.GenP-v.LdP), v.Q = (v.GenQ-v.LdQ), v.Va = v.Va*@@PI/180
		   v.Va = v.Va*@@PI/180
         when v.busType == 2 then 
		   //v.P = (v.GenP-v.LdP), v.Q = (v.GenQ-v.LdQ), v.Va = v.Va*@@PI/180
           v.Va = v.Va*@@PI/180
         when v.busType == 3 then 
           v.Va = v.Va*@@PI/180
         when v.busType == 4 then 
           v.Vm = 0, v.Va = 0, v.P =0 , v.Q =0
         end
       else                           //flat start, set voltage magnitude/angle based on user input
         case when v.busType == 1 or v.busType == 0 then 
           //v.P = (v.GenP-v.LdP), v.Q = (v.GenQ-v.LdQ), v.Vm = initial_Vm, v.Va = initial_Va
		   v.P = (v.GenP-v.LdP), v.Q = (v.GenQ-v.LdQ)  //, v.SE_Va = v.SE_Va*@@PI/180 //v.SE_Vm = @@initial_Vm, v.SE_Va = @@initial_Va
         when v.busType == 2 then 
           //v.P = (v.GenP-v.LdP), v.Q = (v.GenQ-v.LdQ), v.Va = initial_Va 
		   v.P = (v.GenP-v.LdP), v.Q = (v.GenQ-v.LdQ)  //, v.SE_Va = v.SE_Va*@@PI/180 //v.SE_Va = @@initial_Va
         when v.busType == 3 then 
           v.P = (v.GenP-v.LdP), v.Q = (v.GenQ-v.LdQ)   //, v.SE_Va = v.SE_Va*@@PI/180 // v.SE_Va = v.Va*@@PI/180  // need to be chaged later  v.@Vr & v.@Vm
         when v.busType == 4 then 
           v.Vm = 0, v.Va = 0, v.P =0 , v.Q =0
         end
       end,
       
       // Shunt conductance and shunt susceptance at node v
       v.@sumG += v.G,
       v.@sumB += v.B,
 
       @@Bp += 1,
       @@Bpp += 1;
	   
	
    T4 = select v
         from T3:v
	     //WHERE v.island == 1
		 post-accum
		   case when (v.busType != 3) then// if it is NOT the slack bus             
			 case when v.busType == 0 or v.busType == 1 then  //PQ bus
			   @@matrix_all += sort_id_matrix_all(v.exId*100000 + v.exId, v.@sumG, v.@sumB, v.exId - 1, v.@sumBi, v.@sumB, 0),
			   @@vertex += sort_id_vertex(v.exId, v.@pqvdgr+1, v.@pqdgr+1, v.@alldgr+1, v.SE_Vm, v.SE_Va, v.P, v.Q, v.busType)
			 else   //PV bus 
			   @@matrix_all += sort_id_matrix_all(v.exId*100000 + v.exId, v.@sumG, v.@sumB, v.exId - 1, v.@sumBi, 1, 0),
			   @@vertex += sort_id_vertex(v.exId, v.@pqvdgr+1, 1, v.@alldgr+1, v.SE_Vm, v.SE_Va, v.P, v.Q, v.busType)
			 end
		   else     //slack bus
			 @@matrix_all += sort_id_matrix_all(v.exId*100000 + v.exId, v.@sumG, v.@sumB, v.exId - 1, 1, 1, 0),
			 @@vertex += sort_id_vertex(v.exId, 1, 1, v.@alldgr+1, v.SE_Vm, v.SE_Va, v.P, v.Q, v.busType)
		   end;
		   //log(true, v.exId);
}

// comment temporarily

// else 
// {   
  // // run_option is 2 which means:
  // // 1 - @@matrix_Ybus is not empty --> LU factorization was performed in the past
  // // 2 - HeapAccums for the factorized LU structure have been built
  // // There is no need to build them in gsql or sort in expression function. 
  // print "Factorized LU matrices have previously been built. Solve Power Flow!";
  
  // T3 = select v
       // from  T2:v-(topo_connect:e)->TopoND:t
	   // WHERE v.island == 1 and t.island == 1
       // accum   
       // v.@alldgr += 1 // total number of connected branches
       // post-accum
       // // Initialization of the state variables 
       // case when flatstart == 0 then  //not using flat start, set voltage manitude/angle based on input data files
         // case when v.busType == 1 or v.busType == 0 then 
           // //v.P = (v.GenP-v.LdP), v.Q = (v.GenQ-v.LdQ), v.Va = v.Va*@@PI/180
		   // v.Va = v.Va*@@PI/180
         // when v.busType == 2 then 
           // //v.P = (v.GenP-v.LdP), v.Q = (v.GenQ-v.LdQ), v.Va = v.Va*@@PI/180
		   // v.Va = v.Va*@@PI/180
         // when v.busType == 3 then 
           // v.Va = v.Va*@@PI/180
         // when v.busType == 4 then 
           // v.Vm = 0, v.Va = 0, v.P =0 , v.Q =0
         // end
       // else                           //flat start, set voltage magnitude/angle based on user input
         // case when v.busType == 1 or v.busType == 0 then 
           // //v.P = (v.GenP-v.LdP), v.Q = (v.GenQ-v.LdQ), v.Vm = initial_Vm, v.Va = initial_Va
		   // v.Vm = initial_Vm, v.Va = initial_Va
         // when v.busType == 2 then 
           // //v.P = (v.GenP-v.LdP), v.Q = (v.GenQ-v.LdQ), v.Va = initial_Va  // need to be chaged later  v.@Vr & v.@Vm
		   // v.Va = initial_Va  // need to be chaged later  v.@Vr & v.@Vm
         // when v.busType == 3 then 
           // v.Va = v.Va*@@PI/180  // need to be chaged later  v.@Vr & v.@Vm
         // when v.busType == 4 then 
           // v.Vm = 0, v.Va = 0, v.P =0 , v.Q =0
         // end
       // end;

	// T4 = select v
		 // from T3:v  
		 // WHERE v.island == 1
	     // post-accum
	     // @@vertex_Ybus += sort_id_vertex_Ybus(v.exId, v.@alldgr+1, v.Vm, v.Va, v.P, v.Q, v.busType)
  // ;                   
// }   
  
//print @@vertex.size(), @@edge_Bp.size(), @@edge_Bpp.size(), @@edge_e.size();
//print @@vertex, @@edge_Bp, @@edge_Bpp, @@edge_e, @@edge_all;
//print @@vertex, @@edge_all;
//print @@Lp_edge, @@Up_edge, @@vertex_p;
//print @@Lpp_edge, @@Upp_edge, @@vertex_pp;
//print @@vertex_p_id, @@vertex_pp_id;
//print @@p_edge, @@vertex_p;
//print @@pp_edge, @@vertex_pp;


// perform fast-decoupled power flow
if (@@run_option == 0) //perform LU factorization
{ 
  //First factorize B' and B" matrix then perform power flow iteration using forward/backward substitution with resulting LU.
  //add/update of edge and vertex attributes also preform in expression function.
  basecase_result = GRAPHLU_fdpf_LU_factorize_EMS (@@Bp, @@Bpp, @@vertex, @@matrix_all, @@max_iteration, @@max_change);
  
  // Get the solved result
  // Currently these are @s and are only printing into output file.
  // They should also be shown on visualization which would require
  // them to be vertex attributes. 
  T5 = select  s
       from T4:s
       //WHERE s.island == 1
       post-accum
       //s.Vm = GRAPHLU_getVm(s.exId, @@vertex),
       //s.Va = GRAPHLU_getVa(s.exId, @@vertex) *180/@@PI,
	   //s.cal_Vm = GRAPHLU_getVm(s.exId, @@vertex),  
	   //s.cal_Va = GRAPHLU_getVa(s.exId, @@vertex)*180/@@PI;	 
	   s.PF_Vm = GRAPHLU_getVm_EMS(s.exId, @@vertex),  
	   s.PF_Va = GRAPHLU_getVa_EMS(s.exId, @@vertex)*180/@@PI;	   
}

// comment temporarily
// else
// {
  // // run_option is 2, only solve power flow in expression function
  // basecase_result = GRAPHLU_fdpf_LU_solve_EMS (@@vertex_Ybus, @@matrix_all, max_iteration, max_change); 
     
  // // Get the solved result
  // // Currently these are @s and are only printing into output file.
  // // They should also be shown on visualization which would require
  // // them to be vertex attributes. 
  // T5 = select  s
       // from T4:s
	   // WHERE s.island == 1
       // post-accum
       // //s.Vm = GRAPHLU_getVm(s.exId, @@vertex_Ybus),
       // //s.Va = GRAPHLU_getVa(s.exId, @@vertex_Ybus)*180/@@PI,
	   // //s.cal_Vm = GRAPHLU_getVm(s.exId, @@vertex),  
	   // //s.cal_Va = GRAPHLU_getVa(s.exId, @@vertex)*180/@@PI;  
	   // s.Vm = GRAPHLU_getVm_EMS(s.exId, @@vertex),  
	   // s.Va = GRAPHLU_getVa_EMS(s.exId, @@vertex)*180/@@PI;  
// }


  
//    T2 = select s
//        from T2:s-(connected:e)->Gnode:t
//        where e.flag != 100
//           accum 
          
//         s.@sList += "(" + to_string(s.exId) + "-" + to_string(t.exId) + "," + to_string(
//          s.@Vr*t.@Vr * (-1*e.G*cos(s.@Vs-t.@Vs) + (e.B * sin(s.@Vs - t.@Vs)))) + "," +
//          to_string(s.@Vr*t.@Vr * (-1*e.G*sin(s.@Vs-t.@Vs) - (e.B * cos(s.@Vs - t.@Vs)))) + ")"; 
          
   
//    print @@external_counter;
//    print T2.exId, T2.@P, T2.@Q, T2.@Vr, T2.@Vs, T2.@sList > outputFile;
//    print T0.exId, T0.@P, T0.@Q, T0.@Vr, T0.@Vs > outputFile;

// [Testing for Visualization, Chen Yuan]

 T6 = select t 
      from T5:s -(topo_connect:e)->TopoND:t
	  //WHERE s.island == 1 and t.island == 1
	  accum
		double newG = 0,
		double newB = 0,
		double tap_ratio = abs(e.transformer_final_turns_ratio/e.kcount),
		double tap_ratio_square = abs((e.transformer_final_turns_ratio/e.kcount)*(e.transformer_final_turns_ratio/e.kcount)),
		
		case when (e.transformer_final_turns_ratio == 0 or abs(e.transformer_final_turns_ratio) == 1) then
			s.@cal_P += s.PF_Vm*t.PF_Vm * (-1*e.G*cos((s.PF_Va-t.PF_Va)*@@PI/180) + e.B * sin((s.PF_Va - t.PF_Va)*@@PI/180)),
			s.@cal_Q += s.PF_Vm*t.PF_Vm * (-1*e.G*sin((s.PF_Va-t.PF_Va)*@@PI/180) - e.B * cos((s.PF_Va - t.PF_Va)*@@PI/180))
			//log(false, "e.B and e.G", s.exId, t.exId, e.G, e.B)
		
		else
			newG = e.G/abs(tap_ratio),
			newB = e.B/abs(tap_ratio),
			s.@cal_P += s.PF_Vm*t.PF_Vm * (-1*newG*cos((s.PF_Va-t.PF_Va)*@@PI/180) + newB * sin((s.PF_Va - t.PF_Va)*@@PI/180)),
			s.@cal_Q += s.PF_Vm*t.PF_Vm * (-1*newG*sin((s.PF_Va-t.PF_Va)*@@PI/180) - newB * cos((s.PF_Va - t.PF_Va)*@@PI/180))
			//log(false, "e.B and e.G", s.exId, t.exId, newG, newB)             
		end,

			//[Chen Yuan] Testing for Transmission Line Power Flow for Visualization
			// Receiving end P = Vs*Vr*sin(theta_s - theta_r)/X, Q = Vs*(Vs-Vr)*cos(theta_s - theta_r)/X,
			//[Chen Yuan] Testing for Transmission Line Power Flow for Visualization
			// Receiving end P = Vs*Vr*sin(theta_s - theta_r)/X, Q = Vs*(Vs-Vr)*cos(theta_s - theta_r)/X,
			//e.P_TLPF = s.PF_Vm * t.PF_Vm * sin((s.PF_Va - t.PF_Va)*@@PI/180)* e.BIJ, // Transmission line active power flow
			// [Chen Yuan]
			case when (e.transformer_final_turns_ratio == 0) then
				e.P_TLPF = s.M_Vm * t.M_Vm * sin((s.M_Va - t.M_Va)*@@PI/180)* e.B + (s.M_Vm*s.M_Vm - s.M_Vm*t.M_Vm*cos((s.M_Va - t.M_Va)*@@PI/180)) * e.G,
				e.Q_TLPF = - s.M_Vm * s.M_Vm * (-e.B + 0.5*e.hB) - s.M_Vm * t.M_Vm * (e.G*sin((s.M_Va - t.M_Va)*@@PI/180) - (-e.B)*cos((s.M_Va - t.M_Va)*@@PI/180))
			when (e.transformer_final_turns_ratio > 0) then
				e.P_TLPF = s.M_Vm * s.M_Vm * (e.G/tap_ratio_square) - s.M_Vm * t.M_Vm * ((e.G/tap_ratio)*cos((s.M_Va - t.M_Va)*@@PI/180) + (-e.B/tap_ratio)*sin((s.M_Va - t.M_Va)*@@PI/180)),
				e.Q_TLPF = - s.M_Vm * s.M_Vm * (-e.B + 0.5*e.hB) / tap_ratio_square - s.M_Vm * t.M_Vm * ((e.G/tap_ratio)*sin((s.M_Va - t.M_Va)*@@PI/180) - (-e.B/tap_ratio)*cos((s.M_Va - t.M_Va)*@@PI/180))
			else
				e.P_TLPF = s.M_Vm * s.M_Vm * e.G - s.M_Vm * t.M_Vm * ((e.G/tap_ratio)*cos((s.M_Va - t.M_Va)*@@PI/180) + (-e.B/tap_ratio)*sin((s.M_Va - t.M_Va)*@@PI/180)),
				e.Q_TLPF = - s.M_Vm * s.M_Vm * (-e.B + 0.5*e.hB) - s.M_Vm * t.M_Vm * ((e.G/tap_ratio)*sin((s.M_Va - t.M_Va)*@@PI/180) - (-e.B/tap_ratio)*cos((s.M_Va - t.M_Va)*@@PI/180))
			end
			//e.Q_TLPF = s.PF_Vm * (s.PF_Vm - t.PF_Vm) * cos((s.PF_Va - t.PF_Va)*@@PI/180) * e.BIJ, // Transmission line reactive power flow
			//log(true, e.G, e.B)
			

		// [Chen Yuan] Testing violation monitoring for Visualization
		//e.sh = 3.5, // load shedding limit, randomly set for testing
		//e.em = 2.5, // emergency limit, randomly set for testing
		//e.th = 1.5, // thermal limit, randomly set for testing
		//e.CI =0, // transmission line congestion indication
		post-accum
		       s.@cal_P += s.PF_Vm*s.PF_Vm*s.@sumG,
			   s.@cal_Q += (-1) * s.PF_Vm*s.PF_Vm*s.@sumB,
			   s.cal_P = s.@cal_P,
			   s.cal_Q = s.@cal_Q;
  
 T7 = select t 
      from T6:s-(topo_connect:e)->TopoND:t
	  //WHERE s.island == 1 and t.island == 1
	  accum
		case when (sqrt(e.P_TLPF*e.P_TLPF + e.Q_TLPF*e.Q_TLPF) >= e.th and sqrt(e.P_TLPF*e.P_TLPF + e.Q_TLPF*e.Q_TLPF) < e.em) then
		e.CI = 1
		when (sqrt(e.P_TLPF*e.P_TLPF + e.Q_TLPF*e.Q_TLPF) >= e.em and sqrt(e.P_TLPF*e.P_TLPF + e.Q_TLPF*e.Q_TLPF) < e.sh) then
		e.CI = 2
		when (sqrt(e.P_TLPF*e.P_TLPF + e.Q_TLPF*e.Q_TLPF) >= e.sh) then
		e.CI = 3
		else e.CI = 0
		end
			 
		 
		//case when (e.P_TLPF > 0) then
			//case when (e.type == "connected") then
				//@@edgeList += e   // Added by Chen Yuan
			//end
		//when (e.P_TLPF == 0 and s.exId < t.exId) then
			//case when (e.type == "undirect_line") then
				  
				//@@edgeList += changeEdgeType(e)  // CHANGE EDGE TYPE from directed to undirected, since now power flow through this line.
			//end
		//end
	 // log(true, e.P_TLPF, e.Q_TLPF);
	 
	    //e.M_P_TLPF = e.P_TLPF,
		//e.M_Q_TLPF = e.Q_TLPF
	 post-accum
		 //s.up_V = 1.02, // bus voltage upper limit, randomly set for testing
		 //s.lo_V = 0.98, // bus voltage lower limit, randomly set for testing
		 //s.OV = 0, // over voltage indicator
		 //s.UV = 0, // under voltage indicator
		 
		 case when (s.PF_Vm >= s.up_V) then
			s.OV = 1
		 else s.OV = 0
		 end,
		 case when (s.PF_Vm <= s.lo_V) then
			s.UV = 1
		 else s.UV = 0
		 end;
		 //s.Vm = s.Vm,
		 //s.Va = s.Va;
	  
	 
	 
	 
	 //****************** Testing temporarily ends here **********************************************
	 

//	foreach (e in @@edgeList)
//	{
//        update into connected values (e.from_id, e.to_id, e.G, e.B, e.hB, e.transformer_final_turns_ratio, e.kcount, e.BIJ, e.flag, e.P_TLPF, e.Q_TLPF); 
//    }
 
	 
     //print T4.exId, T4.P, T4.Q, T4.Vr, T4.Va, T4.busType, T4.OV, T4.UV > outputFile;
	 // print T2.exId, T2.@P, T2.@Q, T2.@Vr, T2.@Vs, T2.busType, sqrt(T2.@Vr*T2.@Vr+T2.@Vs*T2.@Vs),asin(T2.@Vs/sqrt(T2.@Vr*T2.@Vr+T2.@Vs*T2.@Vs))*180/@@PI; 
     //print @@edgeList;
	 //print @@edgeList > outputFile;
	 //print T5;
	 print T7.exId, T7.P, T7.Q, T7.SE_Vm, T7.SE_Va, T7.PF_Vm, T7.PF_Va, T7.busType, T7.OV, T7.UV TO_CSV "/home/graphsql/output/output.txt";
	 // print T2;
	 
	 

  //print @@p_L_matrix.size(), @@p_U_matrix.size();
  //print @@pp_L_matrix.size(), @@pp_U_matrix.size();
  //print @@p_LU_vertex.size(), @@pp_LU_vertex.size(); 
  //print @@p_LU_vertex_test;
  //print @@LUp_vertex, @@LUpp_vertex;
  //print @@LUpSet.size(), @@LUpSet;
  //print @@LUppSet.size(), @@LUppSet;
  //print @@LUpSet.size(), @@LUppSet.size();
  //print @@run_option;  // if @@run_option = 0,  indicating "Performing LU factorization of B' and B'' matrix and solve Power Flow!"; if @@run_option = 2,  indicating "Factorized LU matrices have previously been built. Solve Power Flow!"; 
  //print basecase_result;
}

install query -ui FDPF_EMS
//install query -optimize

